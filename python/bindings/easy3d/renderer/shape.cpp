#include <easy3d/core/box.h>
#include <easy3d/core/mat.h>
#include <easy3d/core/model.h>
#include <easy3d/core/quat.h>
#include <easy3d/core/vec.h>
#include <easy3d/renderer/camera.h>
#include <easy3d/renderer/drawable.h>
#include <easy3d/renderer/drawable_lines.h>
#include <easy3d/renderer/frame.h>
#include <easy3d/renderer/key_frame_interpolator.h>
#include <easy3d/renderer/manipulated_camera_frame.h>
#include <easy3d/renderer/manipulator.h>
#include <easy3d/renderer/renderer.h>
#include <easy3d/renderer/shape.h>
#include <memory>
#include <ostream>
#include <string>
#include <string_view>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>, false)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*, false)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_easy3d_renderer_shape(pybind11::module_& m)
{
	// easy3d::shape::draw_full_screen_quad(unsigned int, float) file:easy3d/renderer/shape.h line:87
	M("easy3d::shape").def("draw_full_screen_quad", (void (*)(unsigned int, float)) &easy3d::shape::draw_full_screen_quad, "Draws a full screen textured quad.\n \n\n The texture.\n \n\n The depth at which the quad will be drawn. The depth value is the Normalized Device Coordinates\n              within the range [-1.0, 1.0], corresponding to the near and far clipping planes, respectively.\n\nC++: easy3d::shape::draw_full_screen_quad(unsigned int, float) --> void", pybind11::arg("texture"), pybind11::arg("depth"));

	// easy3d::shape::draw_quad(unsigned int, unsigned int, int, int, int, int, int, int, float) file:easy3d/renderer/shape.h line:114
	M("easy3d::shape").def("draw_quad", (void (*)(unsigned int, unsigned int, int, int, int, int, int, int, float)) &easy3d::shape::draw_quad, "Draws a quad defined in the screen space using a bound shader.\n \n\n It binds the vertex position and UVs arrays to the given attribute array indices and draws the quad.\n \n\n The vertex attribute array index that represents position in the current shader.\n \n\n The vertex attribute array index that represents 2D UVs in the current shader.\n \n\n y) The position (i.e., min corner) of the quad.\n \n\n h) The size (i.e., width and height) of the quad.\n \n\n vph) The size (i.e., width and height) of the viewport (of the viewer).\n \n\n The depth at which the quad will be drawn. The depth value is the Normalized Device Coordinates\n              within the range [-1.0, 1.0], corresponding to the near and far clipping planes, respectively.\n\nC++: easy3d::shape::draw_quad(unsigned int, unsigned int, int, int, int, int, int, int, float) --> void", pybind11::arg("position_attrib"), pybind11::arg("texcoord_attrib"), pybind11::arg("x"), pybind11::arg("y"), pybind11::arg("w"), pybind11::arg("h"), pybind11::arg("vpw"), pybind11::arg("vph"), pybind11::arg("depth"));

	// easy3d::shape::draw_full_screen_quad(unsigned int, unsigned int, float) file:easy3d/renderer/shape.h line:125
	M("easy3d::shape").def("draw_full_screen_quad", (void (*)(unsigned int, unsigned int, float)) &easy3d::shape::draw_full_screen_quad, "Draws a full screen quad using the bound shader.\n \n\n It binds the vertex position and UVs arrays to the given attribute array indices and draws the quad.\n \n\n The vertex attribute array index that represents position in the current shader.\n \n\n The vertex attribute array index that represents 2D UVs in the current shader.\n \n\n The depth at which the quad will be drawn. The depth value is the Normalized Device Coordinates\n              within the range [-1.0, 1.0], corresponding to the near and far clipping planes, respectively.\n\nC++: easy3d::shape::draw_full_screen_quad(unsigned int, unsigned int, float) --> void", pybind11::arg("position_attrib"), pybind11::arg("texcoord_attrib"), pybind11::arg("depth"));

	// easy3d::shape::draw_sphere_big_circles(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool) file:easy3d/renderer/shape.h line:164
	M("easy3d::shape").def("draw_sphere_big_circles", [](class easy3d::LinesDrawable * a0, const class easy3d::Mat4<float> & a1, const class easy3d::Mat4<float> & a2) -> void { return easy3d::shape::draw_sphere_big_circles(a0, a1, a2); }, "", pybind11::arg("drawable"), pybind11::arg("mvp"), pybind11::arg("m"));
	M("easy3d::shape").def("draw_sphere_big_circles", (void (*)(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool)) &easy3d::shape::draw_sphere_big_circles, "Draws the outline (the 3 big circles) of a sphere.\n \n\n The drawable.\n \n\n The model view projection matrix.\n \n\n The transformation matrix defining the sphere's location, radius, and orientation.\n \n\n  will also draw the three main axes.\n\nC++: easy3d::shape::draw_sphere_big_circles(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool) --> void", pybind11::arg("drawable"), pybind11::arg("mvp"), pybind11::arg("m"), pybind11::arg("axes"));

	// easy3d::shape::draw_box_wire(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool) file:easy3d/renderer/shape.h line:173
	M("easy3d::shape").def("draw_box_wire", [](class easy3d::LinesDrawable * a0, const class easy3d::Mat4<float> & a1, const class easy3d::Mat4<float> & a2) -> void { return easy3d::shape::draw_box_wire(a0, a1, a2); }, "", pybind11::arg("drawable"), pybind11::arg("mvp"), pybind11::arg("m"));
	M("easy3d::shape").def("draw_box_wire", (void (*)(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool)) &easy3d::shape::draw_box_wire, "Draws a box.\n \n\n The drawable.\n \n\n The model view projection matrix.\n \n\n The transformation matrix defining the box's location, sizes, and orientation.\n \n\n  to draw an abstracted version (only part of its corners).\n\nC++: easy3d::shape::draw_box_wire(class easy3d::LinesDrawable *, const class easy3d::Mat4<float> &, const class easy3d::Mat4<float> &, bool) --> void", pybind11::arg("drawable"), pybind11::arg("mvp"), pybind11::arg("m"), pybind11::arg("abstracted"));

	// easy3d::shape::create_grid(int, int, class std::vector<class easy3d::Vec<3, float> > &, float, float) file:easy3d/renderer/shape.h line:189
	M("easy3d::shape").def("create_grid", [](int const & a0, int const & a1, class std::vector<class easy3d::Vec<3, float> > & a2) -> void { return easy3d::shape::create_grid(a0, a1, a2); }, "", pybind11::arg("x_steps"), pybind11::arg("y_steps"), pybind11::arg("points"));
	M("easy3d::shape").def("create_grid", [](int const & a0, int const & a1, class std::vector<class easy3d::Vec<3, float> > & a2, float const & a3) -> void { return easy3d::shape::create_grid(a0, a1, a2, a3); }, "", pybind11::arg("x_steps"), pybind11::arg("y_steps"), pybind11::arg("points"), pybind11::arg("depth"));
	M("easy3d::shape").def("create_grid", (void (*)(int, int, class std::vector<class easy3d::Vec<3, float> > &, float, float)) &easy3d::shape::create_grid, "Generates data for a grid as a set of line segments.\n \n\n The grid is centered at vec3(0, 0, 0) and lies on the XOY plane.\n \n\n The number of subdivisions along X direction.\n \n\n The number of subdivisions along Y direction.\n \n\n The scaling factor\n \n\n The points to be returned.\n\nC++: easy3d::shape::create_grid(int, int, class std::vector<class easy3d::Vec<3, float> > &, float, float) --> void", pybind11::arg("x_steps"), pybind11::arg("y_steps"), pybind11::arg("points"), pybind11::arg("depth"), pybind11::arg("scale"));

	// easy3d::shape::create_circle(int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<unsigned int> &) file:easy3d/renderer/shape.h line:196
	M("easy3d::shape").def("create_circle", (void (*)(int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<unsigned int> &)) &easy3d::shape::create_circle, "Generates data for a unit circle as a set of line segments.\n \n\n The circle is centered at vec3(0, 0, 0) and lies on the XOY plane.\n \n\n The number of subdivisions.\n\nC++: easy3d::shape::create_circle(int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<unsigned int> &) --> void", pybind11::arg("slices"), pybind11::arg("points"), pybind11::arg("indices"));

	// easy3d::shape::create_box(class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, bool) file:easy3d/renderer/shape.h line:203
	M("easy3d::shape").def("create_box", [](class std::vector<class easy3d::Vec<3, float> > & a0, class std::vector<class easy3d::Vec<3, float> > & a1) -> void { return easy3d::shape::create_box(a0, a1); }, "", pybind11::arg("points"), pybind11::arg("colors"));
	M("easy3d::shape").def("create_box", (void (*)(class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, bool)) &easy3d::shape::create_box, "Generates data for a unit box as a set of line segments.\n \n\n The box is centered at vec3(0, 0, 0) and is aligned with the main axes.\n \n\n  to draw an abstracted version (only part of its corners).\n\nC++: easy3d::shape::create_box(class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, bool) --> void", pybind11::arg("points"), pybind11::arg("colors"), pybind11::arg("abstracted"));

	// easy3d::shape::create_sphere(const class easy3d::Vec<3, float> &, double, int, int, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) file:easy3d/renderer/shape.h line:212
	M("easy3d::shape").def("create_sphere", (void (*)(const class easy3d::Vec<3, float> &, double, int, int, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &)) &easy3d::shape::create_sphere, "Generates data (points, normals, and colors) for a 3D sphere.\n \n\n the radius of the sphere.\n \n\n the number of subdivisions around the z axis (similar to lines of longitude).\n \n\n the number of subdivisions along the z axis(similar to lines of latitude).\n\nC++: easy3d::shape::create_sphere(const class easy3d::Vec<3, float> &, double, int, int, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) --> void", pybind11::arg("center"), pybind11::arg("radius"), pybind11::arg("slices"), pybind11::arg("stacks"), pybind11::arg("color"), pybind11::arg("points"), pybind11::arg("normals"), pybind11::arg("colors"));

	// easy3d::shape::create_checker_sphere(const class easy3d::Vec<3, float> &, double, int, int, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) file:easy3d/renderer/shape.h line:225
	M("easy3d::shape").def("create_checker_sphere", (void (*)(const class easy3d::Vec<3, float> &, double, int, int, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &)) &easy3d::shape::create_checker_sphere, "Generates data (points, normals, and colors) for a 3D checker sphere.\n \n\n the radius of the sphere.\n \n\n the number of subdivisions around the z axis (similar to lines of longitude).\n \n\n the number of subdivisions along the z axis(similar to lines of latitude).\n \n\n how many tiles each checker will occupy\n \n\n and color2: the two interchanging colors\n\nC++: easy3d::shape::create_checker_sphere(const class easy3d::Vec<3, float> &, double, int, int, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) --> void", pybind11::arg("center"), pybind11::arg("radius"), pybind11::arg("slices"), pybind11::arg("stacks"), pybind11::arg("checker_size"), pybind11::arg("color1"), pybind11::arg("color2"), pybind11::arg("points"), pybind11::arg("normals"), pybind11::arg("colors"));

	// easy3d::shape::create_cylinder(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) file:easy3d/renderer/shape.h line:234
	M("easy3d::shape").def("create_cylinder", (void (*)(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &)) &easy3d::shape::create_cylinder, "Prepares data (points, normals, and colors) for a 3D cylinder defined by two 3D points s and t.\n\nC++: easy3d::shape::create_cylinder(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) --> void", pybind11::arg("radius"), pybind11::arg("slices"), pybind11::arg("s"), pybind11::arg("t"), pybind11::arg("color"), pybind11::arg("points"), pybind11::arg("normals"), pybind11::arg("colors"));

	// easy3d::shape::create_cone(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) file:easy3d/renderer/shape.h line:243
	M("easy3d::shape").def("create_cone", (void (*)(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &)) &easy3d::shape::create_cone, "Prepares data (points, normals, and colors) for a 3D cone defined by two 3D points b and t.\n s is the base center and t is the tip.\n\nC++: easy3d::shape::create_cone(double, int, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, const class easy3d::Vec<3, float> &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) --> void", pybind11::arg("radius"), pybind11::arg("slices"), pybind11::arg("s"), pybind11::arg("t"), pybind11::arg("color"), pybind11::arg("points"), pybind11::arg("normals"), pybind11::arg("colors"));

	// easy3d::shape::create_torus(double, double, int, int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) file:easy3d/renderer/shape.h line:257
	M("easy3d::shape").def("create_torus", (void (*)(double, double, int, int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &)) &easy3d::shape::create_torus, "Prepares data for representing a torus.\n \n\n The radius of major circle.\n \n\n The radius of minor circle.\n \n\n The number of subdivisions along the major circle (suggested value 50).\n \n\n The number of subdivisions along the minor circle (suggested value 20).\n \n\n Returns the points.\n \n\n Returns the normals.\n\nC++: easy3d::shape::create_torus(double, double, int, int, class std::vector<class easy3d::Vec<3, float> > &, class std::vector<class easy3d::Vec<3, float> > &) --> void", pybind11::arg("major_radius"), pybind11::arg("minor_radius"), pybind11::arg("major_slices"), pybind11::arg("minor_slices"), pybind11::arg("points"), pybind11::arg("normals"));

	// easy3d::shape::create_camera(class std::vector<class easy3d::Vec<3, float> > &, float, float, float) file:easy3d/renderer/shape.h line:268
	M("easy3d::shape").def("create_camera", [](class std::vector<class easy3d::Vec<3, float> > & a0, float const & a1, float const & a2) -> void { return easy3d::shape::create_camera(a0, a1, a2); }, "", pybind11::arg("points"), pybind11::arg("width"), pybind11::arg("fov"));
	M("easy3d::shape").def("create_camera", (void (*)(class std::vector<class easy3d::Vec<3, float> > &, float, float, float)) &easy3d::shape::create_camera, "Generates data (points) for representing a camera in the 3D world as a set of lines.\n \n\n The width of the camera. A good value can be 5% of the scene radius, or 10% of the\n      character height (in walking mode).\n \n\n The vertical field of view of the camera (in radians).\n \n\n The aspect ratio of the base quad defined as height/width (default 0.6).\n\nC++: easy3d::shape::create_camera(class std::vector<class easy3d::Vec<3, float> > &, float, float, float) --> void", pybind11::arg("points"), pybind11::arg("width"), pybind11::arg("fov"), pybind11::arg("hw_ratio"));

}
