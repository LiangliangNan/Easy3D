#include <easy3d/core/mat.h>
#include <easy3d/core/quat.h>
#include <easy3d/core/vec.h>
#include <easy3d/renderer/constraint.h>
#include <easy3d/renderer/frame.h>
#include <easy3d/renderer/key_frame_interpolator.h>
#include <easy3d/renderer/manipulator.h>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <string_view>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>, false)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*, false)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_easy3d_renderer_key_frame_interpolator(pybind11::module_& m)
{
	{ // easy3d::KeyFrameInterpolator file:easy3d/renderer/key_frame_interpolator.h line:103
		pybind11::class_<easy3d::KeyFrameInterpolator, std::shared_ptr<easy3d::KeyFrameInterpolator>> cl(m, "KeyFrameInterpolator", "A keyframe interpolator for animation generation.\n \n\n\n \n A KeyFrameInterpolator holds keyframes (that define a path) and a pointer to a frame (which will be\n      interpolated) of your application. When the user start_interpolation(), the KeyFrameInterpolator regularly\n      updates the frame() position and orientation along the path.\n\n      A keyframes is defined by a Frame and a time, expressed in seconds. The time has to be monotonously\n      increasing over keyframes. When interpolation_speed() equals 1.0 (default value), these times correspond\n      to actual user's seconds during interpolation (provided that your main loop is fast enough).\n      The interpolation is then real-time: the keyframes will be reached at their keyframe_time().\n\n      When the user start_interpolation(), a timer is started which will update the frame()'s position and\n      orientation every interpolation_period() milliseconds. This update increases the time by\n      interpolation_period() * interpolation_speed() milliseconds. This mechanism ensures that the number of\n      interpolation steps is constant and equal to the total path duration() divided by the\n      interpolation_period() * interpolation_speed(). This is especially useful for benchmarking or movie\n      creation (constant number of snapshots).\n\n      During the interpolation, the KeyFrameInterpolator emits an  Signal which will usually\n      be connected to the viewer's update() method. The interpolation is stopped when duration has reached.\n      Another Signal interpolation_stopped will be emitted when the interpolation reaches its end or the when the\n      stop_interpolation() method was triggered.\n\n      Note that a Camera has a keyframe_interpolator() method, that can be used to drive the Camera along a\n      path, or to restore a saved position (a path made of a single keyframe).\n\n \n The default duration of any two consecutive keyframes is the same. So for a smoother animation, it is\n      suggested to regularly (as equally as possible) sample the viewpoints.\n\n \n If a Constraint is attached to the frame() (see Frame::constraint()), it should be deactivated before \n      is_interpolation_started(), otherwise the interpolated motion (computed as if there was no constraint) will \n      probably be erroneous.\n\n Animation example:\n      \n\n\n\n\n\n\n\n\n\n      \n \n\n Allow edit the duration for each keyframe?  (not sure due to many keyframes and can be annoying).");
		cl.def( pybind11::init( [](){ return new easy3d::KeyFrameInterpolator(); } ), "doc" );
		cl.def( pybind11::init<class easy3d::Frame *>(), pybind11::arg("frame") );


		pybind11::enum_<easy3d::KeyFrameInterpolator::Method>(cl, "Method", pybind11::arithmetic(), "")
			.value("FITTING", easy3d::KeyFrameInterpolator::FITTING)
			.value("INTERPOLATION", easy3d::KeyFrameInterpolator::INTERPOLATION)
			.export_values();

		cl.def_readwrite("frame_interpolated", &easy3d::KeyFrameInterpolator::frame_interpolated);
		cl.def_readwrite("interpolation_stopped", &easy3d::KeyFrameInterpolator::interpolation_stopped);
		cl.def("add_keyframe", (bool (easy3d::KeyFrameInterpolator::*)(const class easy3d::Frame &)) &easy3d::KeyFrameInterpolator::add_keyframe, "Appends a new keyframe to the path.\n \n\n Same as add_keyframe(const Frame&, float), except that the keyframe_time() is automatically set\n      to previous keyframe_time() plus one second (or 0.0 if there is no previous keyframe).\n \n\n  if the keyframe has been successfully added.\n\nC++: easy3d::KeyFrameInterpolator::add_keyframe(const class easy3d::Frame &) --> bool", pybind11::arg("frame"));
		cl.def("add_keyframe", (bool (easy3d::KeyFrameInterpolator::*)(const class easy3d::Frame &, float)) &easy3d::KeyFrameInterpolator::add_keyframe, "Appends a new keyframe to the path, with its associated  (in seconds).\n \n\n The path will use the current  state.\n \n\n  if the keyframe has been successfully added.\n \n\n The keyframe_time() have to be monotonously increasing over keyframes.\n\nC++: easy3d::KeyFrameInterpolator::add_keyframe(const class easy3d::Frame &, float) --> bool", pybind11::arg("frame"), pybind11::arg("time"));
		cl.def("delete_last_keyframe", (void (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::delete_last_keyframe, "Removes the lastly added keyframe from the path.\n \n\n This is the reverse operation of add_keyframe(const Frame&) and add_keyframe(const Frame&, float).\n\nC++: easy3d::KeyFrameInterpolator::delete_last_keyframe() --> void");
		cl.def("set_keyframe_time", (void (easy3d::KeyFrameInterpolator::*)(std::size_t, float)) &easy3d::KeyFrameInterpolator::set_keyframe_time, "Sets the time corresponding to the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n The time  have to be monotonously increasing over keyframes.\n \n\n keyframe_time()\n\nC++: easy3d::KeyFrameInterpolator::set_keyframe_time(std::size_t, float) --> void", pybind11::arg("index"), pybind11::arg("t"));
		cl.def("set_keyframe_position", (void (easy3d::KeyFrameInterpolator::*)(std::size_t, const class easy3d::Vec<3, float> &)) &easy3d::KeyFrameInterpolator::set_keyframe_position, "Sets the position of the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n keyframe_time()\n\nC++: easy3d::KeyFrameInterpolator::set_keyframe_position(std::size_t, const class easy3d::Vec<3, float> &) --> void", pybind11::arg("index"), pybind11::arg("pos"));
		cl.def("set_keyframe_orientation", (void (easy3d::KeyFrameInterpolator::*)(std::size_t, const class easy3d::Quat<float> &)) &easy3d::KeyFrameInterpolator::set_keyframe_orientation, "Sets the orientation of the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n keyframe_time()\n\nC++: easy3d::KeyFrameInterpolator::set_keyframe_orientation(std::size_t, const class easy3d::Quat<float> &) --> void", pybind11::arg("index"), pybind11::arg("q"));
		cl.def("delete_path", (void (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::delete_path, "Removes all keyframes from the path.\n \n\n Upon return, the number_of_keyframes() will return 0.\n\nC++: easy3d::KeyFrameInterpolator::delete_path() --> void");
		cl.def("frame", (class easy3d::Frame * (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::frame, "Returns the associated Frame and that is interpolated by the KeyFrameInterpolator.\n \n\n The returned Frame was set using set_frame() or with the KeyFrameInterpolator constructor.\n      When is_interpolation_started(), this Frame's position and orientation will regularly be updated\n      by a timer, so that they follow the KeyFrameInterpolator path.\n \n\n set_frame()\n\nC++: easy3d::KeyFrameInterpolator::frame() const --> class easy3d::Frame *", pybind11::return_value_policy::automatic);
		cl.def("set_frame", (void (easy3d::KeyFrameInterpolator::*)(class easy3d::Frame *const)) &easy3d::KeyFrameInterpolator::set_frame, "Sets the frame() associated to the KeyFrameInterpolator. \n\nC++: easy3d::KeyFrameInterpolator::set_frame(class easy3d::Frame *const) --> void", pybind11::arg("frame"));
		cl.def("number_of_keyframes", (std::size_t (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::number_of_keyframes, "Returns the number of keyframes used by the interpolation.\n \n\n Use add_keyframe() to add new keyframes.\n\nC++: easy3d::KeyFrameInterpolator::number_of_keyframes() const --> std::size_t");
		cl.def("keyframe", (class easy3d::Frame (easy3d::KeyFrameInterpolator::*)(std::size_t) const) &easy3d::KeyFrameInterpolator::keyframe, "Returns the Frame associated with the keyframe at \n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n keyframe_time()\n\nC++: easy3d::KeyFrameInterpolator::keyframe(std::size_t) const --> class easy3d::Frame", pybind11::arg("index"));
		cl.def("keyframe_time", (float (easy3d::KeyFrameInterpolator::*)(std::size_t) const) &easy3d::KeyFrameInterpolator::keyframe_time, "Returns the time corresponding to the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n set_keyframe_time().\n\nC++: easy3d::KeyFrameInterpolator::keyframe_time(std::size_t) const --> float", pybind11::arg("index"));
		cl.def("keyframe_position", (const class easy3d::Vec<3, float> & (easy3d::KeyFrameInterpolator::*)(std::size_t) const) &easy3d::KeyFrameInterpolator::keyframe_position, "Returns the position of the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n set_keyframe_position()\n\nC++: easy3d::KeyFrameInterpolator::keyframe_position(std::size_t) const --> const class easy3d::Vec<3, float> &", pybind11::return_value_policy::automatic, pybind11::arg("index"));
		cl.def("keyframe_orientation", (const class easy3d::Quat<float> & (easy3d::KeyFrameInterpolator::*)(std::size_t) const) &easy3d::KeyFrameInterpolator::keyframe_orientation, "Returns the orientation of the  keyframe.\n \n\n The  has to be in the range [0, number_of_keyframes()-1].\n \n\n set_keyframe_orientation()\n\nC++: easy3d::KeyFrameInterpolator::keyframe_orientation(std::size_t) const --> const class easy3d::Quat<float> &", pybind11::return_value_policy::automatic, pybind11::arg("index"));
		cl.def("duration", (float (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::duration, "Returns the duration of the KeyFrameInterpolator path, expressed in seconds.\n \n\n The duration simply corresponds to last_time() - first_time(). It returns 0.0 if the path has less\n      than 2 keyframes.\n \n\n keyframe_time().\n\nC++: easy3d::KeyFrameInterpolator::duration() const --> float");
		cl.def("firstTime", (float (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::firstTime, "Returns the time corresponding to the first keyframe, expressed in seconds.\n \n\n Returns 0.0 if the path is empty.\n \n\n last_time(), duration(), and keyframe_time().\n\nC++: easy3d::KeyFrameInterpolator::first_time() const --> float");
		cl.def("lastTime", (float (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::lastTime, "Returns the time corresponding to the last keyframe, expressed in seconds.\n \n\n Returns 0.0 if the path is empty.\n \n\n first_time(), duration(), and keyframe_time().\n\nC++: easy3d::KeyFrameInterpolator::last_time() const --> float");
		cl.def("interpolation_method", (enum easy3d::KeyFrameInterpolator::Method (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::interpolation_method, "Returns the interpolation method.\n \n\n Default value is  (cubic spline interpolation).\n\nC++: easy3d::KeyFrameInterpolator::interpolation_method() const --> enum easy3d::KeyFrameInterpolator::Method");
		cl.def("interpolation_speed", (float (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::interpolation_speed, "Returns the current interpolation speed.\n \n\n Default value is 1.0, which means keyframe_time() will be matched during the interpolation\n      (provided that your main loop is fast enough).\n\nC++: easy3d::KeyFrameInterpolator::interpolation_speed() const --> float");
		cl.def("interpolation_period", (int (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::interpolation_period, "Returns the current interpolation period, expressed in milliseconds.\n \n\n The update of the frame() state will be done by a timer at this period when\n      is_interpolation_started(). This period (multiplied by interpolation_speed()) will be added to be the\n      next frame's time.\n      The interpolation_period() multiplied by frame_rate() is always equal to 1.0.\n\nC++: easy3d::KeyFrameInterpolator::interpolation_period() const --> int");
		cl.def("frame_rate", (int (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::frame_rate, "Returns the desired frame rate. Default value is 30.\n \n\n The frame_rate() multiplied by interpolation_period() is always equal to 1.0.\n\nC++: easy3d::KeyFrameInterpolator::frame_rate() const --> int");
		cl.def("set_interpolation_method", (void (easy3d::KeyFrameInterpolator::*)(enum easy3d::KeyFrameInterpolator::Method)) &easy3d::KeyFrameInterpolator::set_interpolation_method, "Sets the interpolation_method().\n\nC++: easy3d::KeyFrameInterpolator::set_interpolation_method(enum easy3d::KeyFrameInterpolator::Method) --> void", pybind11::arg("m"));
		cl.def("set_interpolation_speed", (void (easy3d::KeyFrameInterpolator::*)(float)) &easy3d::KeyFrameInterpolator::set_interpolation_speed, "Sets the interpolation_speed().\n\nC++: easy3d::KeyFrameInterpolator::set_interpolation_speed(float) --> void", pybind11::arg("speed"));
		cl.def("set_frame_rate", (void (easy3d::KeyFrameInterpolator::*)(int)) &easy3d::KeyFrameInterpolator::set_frame_rate, "Sets the desired frame rate.\n\nC++: easy3d::KeyFrameInterpolator::set_frame_rate(int) --> void", pybind11::arg("fps"));
		cl.def("is_interpolation_started", (bool (easy3d::KeyFrameInterpolator::*)() const) &easy3d::KeyFrameInterpolator::is_interpolation_started, "Returns whether the interpolation is being performed.\n \n\n Use start_interpolation(), stop_interpolation() or toggleInterpolation() to modify this state.\n\nC++: easy3d::KeyFrameInterpolator::is_interpolation_started() const --> bool");
		cl.def("start_interpolation", (void (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::start_interpolation, "Starts the interpolation process.\n \n\n A timer is started with an interpolation_period() period that updates the frame()'s position and\n      orientation. is_interpolation_started() will return  until stop_interpolation() or\n      toggleInterpolation() is called.\n \n\n The keyframes must be defined (see add_keyframe())  you start_interpolation(), or else\n      the interpolation will naturally immediately stop.\n\nC++: easy3d::KeyFrameInterpolator::start_interpolation() --> void");
		cl.def("stop_interpolation", (void (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::stop_interpolation, "Stops an interpolation started with start_interpolation().\n \n\n start_interpolation(), is_interpolation_started(), and toggleInterpolation().\n\nC++: easy3d::KeyFrameInterpolator::stop_interpolation() --> void");
		cl.def("toggle_interpolation", (void (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::toggle_interpolation, "Calls start_interpolation() or stop_interpolation(), depending on is_interpolation_started().\n\nC++: easy3d::KeyFrameInterpolator::toggle_interpolation() --> void");
		cl.def("interpolate", (const class std::vector<class easy3d::Frame> & (easy3d::KeyFrameInterpolator::*)()) &easy3d::KeyFrameInterpolator::interpolate, "Computes and returns all the interpolated frames.\n\nC++: easy3d::KeyFrameInterpolator::interpolate() --> const class std::vector<class easy3d::Frame> &", pybind11::return_value_policy::automatic);
		cl.def("save_keyframes", (bool (easy3d::KeyFrameInterpolator::*)(const std::string &) const) &easy3d::KeyFrameInterpolator::save_keyframes, "saves the camera path to a file\n\nC++: easy3d::KeyFrameInterpolator::save_keyframes(const std::string &) const --> bool", pybind11::arg("file_name"));
		cl.def("read_keyframes", (bool (easy3d::KeyFrameInterpolator::*)(const std::string &)) &easy3d::KeyFrameInterpolator::read_keyframes, "reads camera path from a file\n\nC++: easy3d::KeyFrameInterpolator::read_keyframes(const std::string &) --> bool", pybind11::arg("file_name"));
	}
	{ // easy3d::Manipulator file:easy3d/renderer/manipulator.h line:62
		pybind11::class_<easy3d::Manipulator, std::shared_ptr<easy3d::Manipulator>> cl(m, "Manipulator", "A manipulator is for manipulation of an object.\n \n\n A manipulator maintains the manipulated frame of an object. The manipulated frame is used to\n      manipulate this object. In this implementation, the origin of the manipulated frame is always at\n      the center of the object.\n \n\n\n The following code shows how to use this manipulator:\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n     ");
		cl.def("reset", (void (easy3d::Manipulator::*)()) &easy3d::Manipulator::reset, "Resets the manipulated frame, i.e., no transformation.\n\nC++: easy3d::Manipulator::reset() --> void");
	}
}
