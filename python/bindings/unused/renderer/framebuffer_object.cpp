#include <easy3d/renderer/framebuffer_object.h>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <string_view>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>, false)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*, false)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_easy3d_renderer_framebuffer_object(pybind11::module_& m)
{
	{ // easy3d::FramebufferObject file:easy3d/renderer/framebuffer_object.h line:121
		pybind11::class_<easy3d::FramebufferObject, std::shared_ptr<easy3d::FramebufferObject>> cl(m, "FramebufferObject", "An implementation of framebuffer object (FBO).\n \n\n\n \n A framebuffer object is conceptually a structure containing pointers to GPU memory.\n      The memory pointed to is either an OpenGL texture or an OpenGL RenderBuffer. FBOs can be\n      used to render to one or more textures, share depth buffers between multiple sets of\n      color buffers/textures.\n      http://oss.sgi.com/projects/ogl-sample/registry/EXT/framebuffer_object.txt for details.\n\n      Note that you need to create a FramebufferObject with more than one sample per pixel for\n      primitives to be antialiased. To create a multisample framebuffer object you should set\n      the sample property to a non-zero value. The default sample count of 0 represents a regular\n      non-multisample framebuffer object. If the desired amount of samples per pixel is not\n      supported by the hardware then the maximum number of samples per pixel will be used. The\n      GL_EXT_framebuffer_multisample extension is required to create a framebuffer with more than\n      one sample per pixel.\n\n \n\n      - A valid OpenGL context must be present when creating a FramebufferObject, otherwise initialization will fail.\n      - GL_TEXTURE_2D textures must have a power of 2 width and height(e.g. 256x512), unless you are using OpenGL 2.0\n        or higher.\n      - To create a multisample framebuffer object you should set the sample property to a non-zero value.\n      - If you want to use a multisample framebuffer object a texture, you need to blit it to a regular framebuffer\n        object using blit_framebuffer().\n      - It is more efficient(but not required) to call bind() on an FBO before making multiple method calls.\n        For example :\n 		        \n\n\n\n\n\n\n\n 			To provide a complete encapsulation, the following usage pattern works\n 			correctly but is less efficient :\n 			    \n\n\n\n\n\n\n\n  		The first usage pattern binds the FBO only once, whereas the second usage binds/unbinds the FBO for\n  		each method call.\n\n Example usage 1: draw to a fbo:\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Example usage 2: draw the depth map of an object or a scene:\n      \n\n\n\n\n\n\n\n\n\n\n For both the above examples, it's easy to enable MSAA by creating a multisample FBO and render to it.\n But do remember to blit to a normal FBO before using the   texture.\n\n Current implement support only GL_TEXTURE_2D (see the texture_target_ variable), and it does not manage\n externally created textures.\n \n\n\n   - add a class TextureFormat for flexible format specification and add related\n     functions using the TextureFormat class.\n   - modify the attach_color_texture() and attach_depth_texture() to use TextureFormat.\n   - replace ColorAttachment by TextureFormat.");
		cl.def( pybind11::init( [](int const & a0, int const & a1){ return new easy3d::FramebufferObject(a0, a1); } ), "doc" , pybind11::arg("w"), pybind11::arg("h"));
		cl.def( pybind11::init<int, int, int>(), pybind11::arg("w"), pybind11::arg("h"), pybind11::arg("samples") );

		cl.def_static("is_supported", (bool (*)()) &easy3d::FramebufferObject::is_supported, "Queries if FramebufferObject is supported.\n\nC++: easy3d::FramebufferObject::is_supported() --> bool");
		cl.def("add_color_texture", [](easy3d::FramebufferObject &o) -> bool { return o.add_color_texture(); }, "");
		cl.def("add_color_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0) -> bool { return o.add_color_texture(a0); }, "", pybind11::arg("internal_format"));
		cl.def("add_color_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0, unsigned int const & a1) -> bool { return o.add_color_texture(a0, a1); }, "", pybind11::arg("internal_format"), pybind11::arg("format"));
		cl.def("add_color_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0, unsigned int const & a1, unsigned int const & a2) -> bool { return o.add_color_texture(a0, a1, a2); }, "", pybind11::arg("internal_format"), pybind11::arg("format"), pybind11::arg("type"));
		cl.def("add_color_texture", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::add_color_texture, "Add a color texture render buffer.\n\nC++: easy3d::FramebufferObject::add_color_texture(unsigned int, unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("internal_format"), pybind11::arg("format"), pybind11::arg("type"), pybind11::arg("filter"));
		cl.def("add_color_buffer", [](easy3d::FramebufferObject &o) -> bool { return o.add_color_buffer(); }, "");
		cl.def("add_color_buffer", [](easy3d::FramebufferObject &o, unsigned int const & a0) -> bool { return o.add_color_buffer(a0); }, "", pybind11::arg("internal_format"));
		cl.def("add_color_buffer", [](easy3d::FramebufferObject &o, unsigned int const & a0, unsigned int const & a1) -> bool { return o.add_color_buffer(a0, a1); }, "", pybind11::arg("internal_format"), pybind11::arg("format"));
		cl.def("add_color_buffer", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::add_color_buffer, "Add a color render buffer.\n\nC++: easy3d::FramebufferObject::add_color_buffer(unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("internal_format"), pybind11::arg("format"), pybind11::arg("type"));
		cl.def("add_depth_texture", [](easy3d::FramebufferObject &o) -> bool { return o.add_depth_texture(); }, "");
		cl.def("add_depth_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0) -> bool { return o.add_depth_texture(a0); }, "", pybind11::arg("internal_format"));
		cl.def("add_depth_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0, unsigned int const & a1) -> bool { return o.add_depth_texture(a0, a1); }, "", pybind11::arg("internal_format"), pybind11::arg("filter"));
		cl.def("add_depth_texture", [](easy3d::FramebufferObject &o, unsigned int const & a0, unsigned int const & a1, unsigned int const & a2) -> bool { return o.add_depth_texture(a0, a1, a2); }, "", pybind11::arg("internal_format"), pybind11::arg("filter"), pybind11::arg("compare_mode"));
		cl.def("add_depth_texture", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::add_depth_texture, "Add a depth texture render buffer.\n\nC++: easy3d::FramebufferObject::add_depth_texture(unsigned int, unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("internal_format"), pybind11::arg("filter"), pybind11::arg("compare_mode"), pybind11::arg("compare_func"));
		cl.def("add_depth_buffer", [](easy3d::FramebufferObject &o) -> bool { return o.add_depth_buffer(); }, "");
		cl.def("add_depth_buffer", (bool (easy3d::FramebufferObject::*)(unsigned int)) &easy3d::FramebufferObject::add_depth_buffer, "Add a depth render buffer.\n\nC++: easy3d::FramebufferObject::add_depth_buffer(unsigned int) --> bool", pybind11::arg("internal_format"));
		cl.def("attach_color_texture", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::attach_color_texture, "Attach an existing color texture to the framebuffer\n \n\n GL_TEXTURE_2D, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_ARRAY\n \n\n GL_COLOR_ATTACHMENTi\n\nC++: easy3d::FramebufferObject::attach_color_texture(unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("target"), pybind11::arg("texture_id"), pybind11::arg("attachment"));
		cl.def("attach_depth_texture", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::attach_depth_texture, "Attach an existing depth texture to the framebuffer\n \n\n GL_TEXTURE_2D, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_ARRAY\n \n\n GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT.\n\nC++: easy3d::FramebufferObject::attach_depth_texture(unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("target"), pybind11::arg("texture_id"), pybind11::arg("attachment"));
		cl.def("ensure_size", (void (easy3d::FramebufferObject::*)(int, int)) &easy3d::FramebufferObject::ensure_size, "Ensure the size of the buffers is  h).\n If its size matches the required size, i.e, (w, h), it does nothing.\n If doesn't match, it clears and reallocate memory in the GPU.\n\nC++: easy3d::FramebufferObject::ensure_size(int, int) --> void", pybind11::arg("w"), pybind11::arg("h"));
		cl.def("bind", [](easy3d::FramebufferObject &o) -> bool { return o.bind(); }, "");
		cl.def("bind", (bool (easy3d::FramebufferObject::*)(unsigned int)) &easy3d::FramebufferObject::bind, "Bind FBO to FRAMEBUFFER, DRAW_FRAMEBUFFER, or READ_FRAMEBUFFER\n The current binding is saved for later release.\n \n\n bind() and release() should be called in pair.\n\nC++: easy3d::FramebufferObject::bind(unsigned int) --> bool", pybind11::arg("target"));
		cl.def("release", [](easy3d::FramebufferObject &o) -> bool { return o.release(); }, "");
		cl.def("release", (bool (easy3d::FramebufferObject::*)(unsigned int)) &easy3d::FramebufferObject::release, "Switches rendering back to the default framebuffer.\n\nC++: easy3d::FramebufferObject::release(unsigned int) --> bool", pybind11::arg("target"));
		cl.def("is_valid", (bool (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::is_valid, "Returns true if the framebuffer object is valid.\n\nC++: easy3d::FramebufferObject::is_valid() const --> bool");
		cl.def("is_bound", [](easy3d::FramebufferObject const &o) -> bool { return o.is_bound(); }, "");
		cl.def("is_bound", (bool (easy3d::FramebufferObject::*)(unsigned int) const) &easy3d::FramebufferObject::is_bound, "Check if the framebuffer object is currently bound to the current context.\n\nC++: easy3d::FramebufferObject::is_bound(unsigned int) const --> bool", pybind11::arg("target"));
		cl.def("activate_draw_buffer", (void (easy3d::FramebufferObject::*)(unsigned int) const) &easy3d::FramebufferObject::activate_draw_buffer, "Choose the buffers to render into. This command lets you select which attachments are written to.\n \n\n The default buffer is the 0. In such a case calling to this function is optional.\n\nC++: easy3d::FramebufferObject::activate_draw_buffer(unsigned int) const --> void", pybind11::arg("index"));
		cl.def("activate_draw_buffers", (void (easy3d::FramebufferObject::*)(unsigned int, unsigned int) const) &easy3d::FramebufferObject::activate_draw_buffers, "C++: easy3d::FramebufferObject::activate_draw_buffers(unsigned int, unsigned int) const --> void", pybind11::arg("minId"), pybind11::arg("maxId"));
		cl.def("deactivate_draw_buffers", (void (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::deactivate_draw_buffers, "C++: easy3d::FramebufferObject::deactivate_draw_buffers() const --> void");
		cl.def("activate_read_buffer", (void (easy3d::FramebufferObject::*)(unsigned int) const) &easy3d::FramebufferObject::activate_read_buffer, "Choose the buffers to read from. This command lets you select which attachment to read from.\n \n\n The default buffer is the 0. In such a case calling to this function is optional.\n\nC++: easy3d::FramebufferObject::activate_read_buffer(unsigned int) const --> void", pybind11::arg("index"));
		cl.def("deactivate_read_buffer", (void (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::deactivate_read_buffer, "Deactivates reading from the buffers.\n\nC++: easy3d::FramebufferObject::deactivate_read_buffer() const --> void");
		cl.def("handle", (unsigned int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::handle, "Returns the OpenGL framebuffer object handle for this framebuffer object (returned by the glGenFramebuffers() function).\n This handle can be used to attach new images or buffers to the framebuffer. If you attach images or buffers, you are\n responsible for cleaning up and destroying these objects.\n\nC++: easy3d::FramebufferObject::handle() const --> unsigned int");
		cl.def("width", (int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::width, "Returns the width of the render buffers.\n\nC++: easy3d::FramebufferObject::width() const --> int");
		cl.def("height", (int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::height, "Returns the height of the render buffers.\n\nC++: easy3d::FramebufferObject::height() const --> int");
		cl.def("samples", (int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::samples, "The returned value can be greater than the requested value since the typically supported\n values are 0, 4, 8, ..., and the requests are mapped to the next supported value.\n\nC++: easy3d::FramebufferObject::samples() const --> int");
		cl.def("num_color_attachments", (int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::num_color_attachments, "Returns the number of color attachments\n\nC++: easy3d::FramebufferObject::num_color_attachments() const --> int");
		cl.def("has_color_attachment", (bool (easy3d::FramebufferObject::*)(unsigned int) const) &easy3d::FramebufferObject::has_color_attachment, "Does the fbo have color attachment at \n\nC++: easy3d::FramebufferObject::has_color_attachment(unsigned int) const --> bool", pybind11::arg("index"));
		cl.def("has_depth_attachment", (bool (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::has_depth_attachment, "Does the fbo have a depth attachment.\n\nC++: easy3d::FramebufferObject::has_depth_attachment() const --> bool");
		cl.def("depth_bits", (int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::depth_bits, "Returns the depth bits.\n\nC++: easy3d::FramebufferObject::depth_bits() const --> int");
		cl.def("has_stencil", (bool (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::has_stencil, "Does the fbo have a stencil buffer.\n\nC++: easy3d::FramebufferObject::has_stencil() const --> bool");
		cl.def("texture_target", (unsigned int (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::texture_target, "Returns the texture target, i.e., GL_TEXTURE_2D or GL_TEXTURE_2D_MULTISAMPLE\n\nC++: easy3d::FramebufferObject::texture_target() const --> unsigned int");
		cl.def("color_texture", [](easy3d::FramebufferObject const &o) -> unsigned int { return o.color_texture(); }, "");
		cl.def("color_texture", [](easy3d::FramebufferObject const &o, unsigned int const & a0) -> unsigned int { return o.color_texture(a0); }, "", pybind11::arg("index"));
		cl.def("color_texture", (unsigned int (easy3d::FramebufferObject::*)(unsigned int, bool) const) &easy3d::FramebufferObject::color_texture, "Returns the texture id attached to the color attachment  of this framebuffer object.\n \n\n The index of the color attachment.\n \n\n If a multisample framebuffer object is used, the function blits and returns the resolved\n      non-multisample texture when  is true.\n \n\n The ID of the color texture.\n\nC++: easy3d::FramebufferObject::color_texture(unsigned int, bool) const --> unsigned int", pybind11::arg("index"), pybind11::arg("resolve"));
		cl.def("has_color_texture", (bool (easy3d::FramebufferObject::*)(unsigned int) const) &easy3d::FramebufferObject::has_color_texture, "Does the fbo have a color texture for color attachment \n\nC++: easy3d::FramebufferObject::has_color_texture(unsigned int) const --> bool", pybind11::arg("index"));
		cl.def("depth_texture", [](easy3d::FramebufferObject const &o) -> unsigned int { return o.depth_texture(); }, "");
		cl.def("depth_texture", (unsigned int (easy3d::FramebufferObject::*)(bool) const) &easy3d::FramebufferObject::depth_texture, "Returns the texture id for the texture attached to the depth attachment of this framebuffer object.\n \n\n If a multisample framebuffer object is used, the function blits and returns the resolved\n      non-multisample texture if  is true.\n \n\n The ID of the depth texture.\n\nC++: easy3d::FramebufferObject::depth_texture(bool) const --> unsigned int", pybind11::arg("resolve"));
		cl.def("has_depth_texture", (bool (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::has_depth_texture, "Does the fbo have a depth texture?\n\nC++: easy3d::FramebufferObject::has_depth_texture() const --> bool");
		cl.def("copy_color_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0) -> bool { return o.copy_color_to_texture(a0); }, "", pybind11::arg("texture_handle"));
		cl.def("copy_color_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0, unsigned int const & a1) -> bool { return o.copy_color_to_texture(a0, a1); }, "", pybind11::arg("texture_handle"), pybind11::arg("index"));
		cl.def("copy_color_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0, unsigned int const & a1, int const & a2) -> bool { return o.copy_color_to_texture(a0, a1, a2); }, "", pybind11::arg("texture_handle"), pybind11::arg("index"), pybind11::arg("internalFormat"));
		cl.def("copy_color_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0, unsigned int const & a1, int const & a2, unsigned int const & a3) -> bool { return o.copy_color_to_texture(a0, a1, a2, a3); }, "", pybind11::arg("texture_handle"), pybind11::arg("index"), pybind11::arg("internalFormat"), pybind11::arg("format"));
		cl.def("copy_color_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0, unsigned int const & a1, int const & a2, unsigned int const & a3, unsigned int const & a4) -> bool { return o.copy_color_to_texture(a0, a1, a2, a3, a4); }, "", pybind11::arg("texture_handle"), pybind11::arg("index"), pybind11::arg("internalFormat"), pybind11::arg("format"), pybind11::arg("type"));
		cl.def("copy_color_to_texture", (bool (easy3d::FramebufferObject::*)(unsigned int &, unsigned int, int, unsigned int, unsigned int, unsigned int)) &easy3d::FramebufferObject::copy_color_to_texture, "Makes a copy of the current buffer into a texture (regardless the attachments already have textures).\n \n\n Internally it creates a texture and uses glCopyTexSubImage2D() to directly copy the buffer in it.\n\n \n The target texture (will be created if it does not exist).\n \n\n The index of the color attachment.\n \n\n format, type Used to define the texture format and hence which and how components of the\n      buffer are copied into the texture. See the glTexImage2D() documentation for details.\n \n\n Specifies how the texture minifying and magnification function work.\n\n The typical internalFormat/format/type combinations are:\n      For depth:	GL_DEPTH_COMPONENT32, GL_DEPTH_COMPONENT24 / GL_DEPTH_COMPONENT / GL_UNSIGNED_BYTE\n			        GL_DEPTH_COMPONENT32F / GL_DEPTH_COMPONENT / GL_FLOAT\n	    For color: 	GL_RGBA8 / GL_RGBA / GL_UNSIGNED_BYTE\n			         mus be GL_[components][size][type], e.g., GL_RG8, GL_RGBA16, GL_R16F,\n			           GL_RG16, GL_RGBA32F ...\n                   must be one of the GL_RED, GL_RG, GL_RGB, GL_BGR, GL_BGRA ...\n					 can be GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT,\n					   GL_INT, GL_FLOAT ...\n	Use GL_LUMINANCE as the  and GL_RED, GL_GREEN or GL_BLUE as  to capture a single\n	color component as a luminance (gray scaled) value.\n \n\n  on success.\n \n\n\n      - GL_STENCIL is not supported as a format.\n		- The GL_DEPTH_COMPONENT format may not be supported by all hardware. It may sometimes be emulated in\n		  software, resulting in poor performances.\n		- You need to release the texture when you're done.\n\nC++: easy3d::FramebufferObject::copy_color_to_texture(unsigned int &, unsigned int, int, unsigned int, unsigned int, unsigned int) --> bool", pybind11::arg("texture_handle"), pybind11::arg("index"), pybind11::arg("internalFormat"), pybind11::arg("format"), pybind11::arg("type"), pybind11::arg("filter"));
		cl.def("copy_depth_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0) -> bool { return o.copy_depth_to_texture(a0); }, "", pybind11::arg("texture_handle"));
		cl.def("copy_depth_to_texture", [](easy3d::FramebufferObject &o, unsigned int & a0, unsigned int const & a1) -> bool { return o.copy_depth_to_texture(a0, a1); }, "", pybind11::arg("texture_handle"), pybind11::arg("internal_format"));
		cl.def("copy_depth_to_texture", (bool (easy3d::FramebufferObject::*)(unsigned int &, unsigned int, unsigned int)) &easy3d::FramebufferObject::copy_depth_to_texture, "Makes a copy of the current depth buffer into a texture.\n \n\n The target texture (will be created if it does not exist).\n \n\n Used to define the texture format.\n \n\n Specifies how the texture minifying and magnification function work.\n \n\n  on success.\n \n\n\n		- You need to release the texture when you're done.\n\nC++: easy3d::FramebufferObject::copy_depth_to_texture(unsigned int &, unsigned int, unsigned int) --> bool", pybind11::arg("texture_handle"), pybind11::arg("internal_format"), pybind11::arg("filter"));
		cl.def("print_attachments", (void (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::print_attachments, "Print all the attachments of the current framebuffer object.\n\nC++: easy3d::FramebufferObject::print_attachments() const --> void");
		cl.def("print_draw_buffers", (void (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::print_draw_buffers, "Print the draw buffers.\n\nC++: easy3d::FramebufferObject::print_draw_buffers() const --> void");
		cl.def("print_read_buffer", (void (easy3d::FramebufferObject::*)() const) &easy3d::FramebufferObject::print_read_buffer, "Print the read buffer.\n\nC++: easy3d::FramebufferObject::print_read_buffer() const --> void");
		cl.def("read_color", [](easy3d::FramebufferObject const &o, unsigned int const & a0, unsigned char * a1, unsigned int const & a2) -> bool { return o.read_color(a0, a1, a2); }, "", pybind11::arg("index"), pybind11::arg("buffer"), pybind11::arg("format"));
		cl.def("read_color", (bool (easy3d::FramebufferObject::*)(unsigned int, unsigned char *, unsigned int, bool) const) &easy3d::FramebufferObject::read_color, "Read the color render buffer attached to color attachment \n \n\n The format of the pixel data. The following formats are accepted: GL_RGB, GL_BGR, GL_RGBA,\n         and GL_BGRA.\n\nC++: easy3d::FramebufferObject::read_color(unsigned int, unsigned char *, unsigned int, bool) const --> bool", pybind11::arg("index"), pybind11::arg("buffer"), pybind11::arg("format"), pybind11::arg("flip_vertically"));
		cl.def("read_color", [](easy3d::FramebufferObject const &o, unsigned int const & a0, class std::vector<unsigned char> & a1, unsigned int const & a2) -> bool { return o.read_color(a0, a1, a2); }, "", pybind11::arg("index"), pybind11::arg("buffer"), pybind11::arg("format"));
		cl.def("read_color", (bool (easy3d::FramebufferObject::*)(unsigned int, class std::vector<unsigned char> &, unsigned int, bool) const) &easy3d::FramebufferObject::read_color, "Read the color render buffer attached to color attachment \n \n\n The format of the pixel data. The following formats are accepted: GL_RGB, GL_BGR, GL_RGBA,\n         and GL_BGRA.\n\nC++: easy3d::FramebufferObject::read_color(unsigned int, class std::vector<unsigned char> &, unsigned int, bool) const --> bool", pybind11::arg("index"), pybind11::arg("buffer"), pybind11::arg("format"), pybind11::arg("flip_vertically"));
		cl.def("read_depth", [](easy3d::FramebufferObject const &o, float * a0) -> bool { return o.read_depth(a0); }, "", pybind11::arg("buffer"));
		cl.def("read_depth", (bool (easy3d::FramebufferObject::*)(float *, bool) const) &easy3d::FramebufferObject::read_depth, "Read the depth render buffer into a specified buffer.\n\nC++: easy3d::FramebufferObject::read_depth(float *, bool) const --> bool", pybind11::arg("buffer"), pybind11::arg("flip_vertically"));
		cl.def("read_depth", [](easy3d::FramebufferObject const &o, class std::vector<float> & a0) -> bool { return o.read_depth(a0); }, "", pybind11::arg("buffer"));
		cl.def("read_depth", (bool (easy3d::FramebufferObject::*)(class std::vector<float> &, bool) const) &easy3d::FramebufferObject::read_depth, "Read the depth render buffer into a specified buffer.\n\nC++: easy3d::FramebufferObject::read_depth(class std::vector<float> &, bool) const --> bool", pybind11::arg("buffer"), pybind11::arg("flip_vertically"));
		cl.def("read_depth", (bool (easy3d::FramebufferObject::*)(float &, int, int) const) &easy3d::FramebufferObject::read_depth, "Reads the depth at pixel  y).\n Returns  if the depth attachment does not exist.\n \n\n  y) are in the OpenGL coordinate system.\n\nC++: easy3d::FramebufferObject::read_depth(float &, int, int) const --> bool", pybind11::arg("depth"), pybind11::arg("x"), pybind11::arg("y"));
		cl.def("snapshot_color", (bool (easy3d::FramebufferObject::*)(unsigned int, const std::string &) const) &easy3d::FramebufferObject::snapshot_color, "Snapshots the color render buffer attached to color attachment  into an image file.\n \n\n Only png, jpg, bmp, tga, ppm are supported. File format is determined by the given extension.\n\nC++: easy3d::FramebufferObject::snapshot_color(unsigned int, const std::string &) const --> bool", pybind11::arg("index"), pybind11::arg("file_name"));
		cl.def("snapshot_depth", (bool (easy3d::FramebufferObject::*)(const std::string &) const) &easy3d::FramebufferObject::snapshot_depth, "Snapshots the color render buffer into an image file.\n \n\n Only png, jpg, bmp, tga, ppm are supported. File format is determined by the given extension.\n\nC++: easy3d::FramebufferObject::snapshot_depth(const std::string &) const --> bool", pybind11::arg("file_name"));
		cl.def_static("blit_framebuffer", [](class easy3d::FramebufferObject * a0, const class easy3d::FramebufferObject * a1, unsigned int const & a2) -> void { return easy3d::FramebufferObject::blit_framebuffer(a0, a1, a2); }, "", pybind11::arg("target"), pybind11::arg("source"), pybind11::arg("buffers"));
		cl.def_static("blit_framebuffer", (void (*)(class easy3d::FramebufferObject *, const class easy3d::FramebufferObject *, unsigned int, unsigned int)) &easy3d::FramebufferObject::blit_framebuffer, "Blit the whole sized buffer\n\n \n Blits from the source rectangle in the source framebuffer object to the target rectangle in the\n      target framebuffer object. If source or target is 0, the default framebuffer will be used instead\n      of a framebuffer object as source or target respectively. The buffers parameter should be a mask\n      consisting of any combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.\n      Any buffer type that is not present both in the source and target buffers is ignored.\n\n      The source and target rectangles may have different sizes; in this case buffers should not contain\n      GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT. The filter parameter should be set to GL_LINEAR or\n      GL_NEAREST specifying whether linear or nearest interpolation should be used for scaling.\n      For GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT, the filter parameter must be GL_NEAREST.\n\n      If source equals target a copy is performed within the same buffer. Results are undefined if the\n      source and target rectangles overlap and have different sizes. The sizes must also be the same\n      if any of the framebuffer objects are multisample framebuffers.\n\n      When multiple render targets are in use, source_color_attachment_index and target_color_attachment_index\n      specify the index of the color attachments in the source and destination framebuffers.\n\n \n The scissor test will restrict the blit area if enabled.\n\nC++: easy3d::FramebufferObject::blit_framebuffer(class easy3d::FramebufferObject *, const class easy3d::FramebufferObject *, unsigned int, unsigned int) --> void", pybind11::arg("target"), pybind11::arg("source"), pybind11::arg("buffers"), pybind11::arg("filter"));
		cl.def_static("blit_framebuffer", [](class easy3d::FramebufferObject * a0, const class easy3d::FramebufferObject * a1, int const & a2, int const & a3, unsigned int const & a4) -> void { return easy3d::FramebufferObject::blit_framebuffer(a0, a1, a2, a3, a4); }, "", pybind11::arg("target"), pybind11::arg("source"), pybind11::arg("target_color_attachment_index"), pybind11::arg("source_color_attachment_index"), pybind11::arg("buffers"));
		cl.def_static("blit_framebuffer", (void (*)(class easy3d::FramebufferObject *, const class easy3d::FramebufferObject *, int, int, unsigned int, unsigned int)) &easy3d::FramebufferObject::blit_framebuffer, "Blit the whole sized buffer of a specific color attachment.\n\nC++: easy3d::FramebufferObject::blit_framebuffer(class easy3d::FramebufferObject *, const class easy3d::FramebufferObject *, int, int, unsigned int, unsigned int) --> void", pybind11::arg("target"), pybind11::arg("source"), pybind11::arg("target_color_attachment_index"), pybind11::arg("source_color_attachment_index"), pybind11::arg("buffers"), pybind11::arg("filter"));
		cl.def_static("blit_framebuffer", [](class easy3d::FramebufferObject * a0, int const & a1, int const & a2, int const & a3, int const & a4, const class easy3d::FramebufferObject * a5, int const & a6, int const & a7, int const & a8, int const & a9, unsigned int const & a10) -> void { return easy3d::FramebufferObject::blit_framebuffer(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); }, "", pybind11::arg("target"), pybind11::arg("tx0"), pybind11::arg("ty0"), pybind11::arg("tx1"), pybind11::arg("ty1"), pybind11::arg("source"), pybind11::arg("sx0"), pybind11::arg("sy0"), pybind11::arg("sx1"), pybind11::arg("sy1"), pybind11::arg("buffers"));
		cl.def_static("blit_framebuffer", (void (*)(class easy3d::FramebufferObject *, int, int, int, int, const class easy3d::FramebufferObject *, int, int, int, int, unsigned int, unsigned int)) &easy3d::FramebufferObject::blit_framebuffer, "Blit a specified region\n\nC++: easy3d::FramebufferObject::blit_framebuffer(class easy3d::FramebufferObject *, int, int, int, int, const class easy3d::FramebufferObject *, int, int, int, int, unsigned int, unsigned int) --> void", pybind11::arg("target"), pybind11::arg("tx0"), pybind11::arg("ty0"), pybind11::arg("tx1"), pybind11::arg("ty1"), pybind11::arg("source"), pybind11::arg("sx0"), pybind11::arg("sy0"), pybind11::arg("sx1"), pybind11::arg("sy1"), pybind11::arg("buffers"), pybind11::arg("filter"));
		cl.def_static("blit_framebuffer", [](class easy3d::FramebufferObject * a0, int const & a1, int const & a2, int const & a3, int const & a4, const class easy3d::FramebufferObject * a5, int const & a6, int const & a7, int const & a8, int const & a9, int const & a10, int const & a11, unsigned int const & a12) -> void { return easy3d::FramebufferObject::blit_framebuffer(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }, "", pybind11::arg("target"), pybind11::arg("tx0"), pybind11::arg("ty0"), pybind11::arg("tx1"), pybind11::arg("ty1"), pybind11::arg("source"), pybind11::arg("sx0"), pybind11::arg("sy0"), pybind11::arg("sx1"), pybind11::arg("sy1"), pybind11::arg("target_color_attachment_index"), pybind11::arg("source_color_attachment_index"), pybind11::arg("buffers"));
		cl.def_static("blit_framebuffer", (void (*)(class easy3d::FramebufferObject *, int, int, int, int, const class easy3d::FramebufferObject *, int, int, int, int, int, int, unsigned int, unsigned int)) &easy3d::FramebufferObject::blit_framebuffer, "Blit a specified region of a specific color attachment.\n\nC++: easy3d::FramebufferObject::blit_framebuffer(class easy3d::FramebufferObject *, int, int, int, int, const class easy3d::FramebufferObject *, int, int, int, int, int, int, unsigned int, unsigned int) --> void", pybind11::arg("target"), pybind11::arg("tx0"), pybind11::arg("ty0"), pybind11::arg("tx1"), pybind11::arg("ty1"), pybind11::arg("source"), pybind11::arg("sx0"), pybind11::arg("sy0"), pybind11::arg("sx1"), pybind11::arg("sy1"), pybind11::arg("target_color_attachment_index"), pybind11::arg("source_color_attachment_index"), pybind11::arg("buffers"), pybind11::arg("filter"));
	}
}
